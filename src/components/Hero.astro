---

---

<section class="hero relative flex h-[60vh] items-center justify-center">
  <canvas id="gridCanvas" class="h-full w-full"></canvas>
  <div class="pointer-events-none absolute text-center">
    <span class="text-3xl font-bold">Feeling</span>
    <h6 id="rotating-text" class="ml-2 inline-block w-[200px] text-5xl font-bold">FUN</h6>
  </div>
</section>

<script>
  const words = [
    'FUN',
    'CREATIVE',
    'BOLD',
    'UNIQUE',
    'DYNAMIC',
    'INNOVATIVE',
    'PLAYFUL',
    'EXCITING',
    'FRESH',
    'MODERN',
    'VIBRANT',
    'POWERFUL',
    'SKILLED',
    'ARTISTIC',
    'PASSIONATE',
  ]

  let currentWordIndex = 0
  const rotatingText = document.getElementById('rotating-text')

  function rotateWords() {
    currentWordIndex = (currentWordIndex + 1) % words.length
    if (rotatingText) {
      rotatingText.textContent = words[currentWordIndex]
    }

    // Random delay between 100ms and 2000ms
    const delay = Math.random() < 0.1 ? 1000 : 100
    setTimeout(rotateWords, delay)
  }

  rotateWords()

  const canvas = document.getElementById('gridCanvas') as HTMLCanvasElement
  const ctx = canvas.getContext('2d') as CanvasRenderingContext2D

  const cellSize = 10
  let rows, cols, grid

  function setupCanvas() {
    canvas.width = canvas.offsetWidth
    canvas.height = canvas.offsetHeight

    rows = Math.ceil(canvas.height / cellSize) + 1
    cols = Math.ceil(canvas.width / cellSize) + 1

    grid = Array(rows)
      .fill(undefined)
      .map(() => Array(cols).fill(0))

    drawGrid()
    animate()
  }

  function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = col * cellSize
        const y = row * cellSize

        if (x < canvas.width && y < canvas.height) {
          const opacity = grid[row][col]
          if (opacity > 0) {
            ctx.fillStyle = `rgba(40, 54, 24, ${opacity * 0.8})` // Updated color and opacity
            ctx.fillRect(x, y, cellSize - 1, cellSize - 1)
          }
        }
      }
    }
  }

  function animate() {
    let needsUpdate = false

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (grid[row][col] > 0) {
          grid[row][col] -= 0.01 // Slowed down the fade slightly
          if (grid[row][col] < 0) grid[row][col] = 0
          needsUpdate = true
        }
      }
    }

    if (needsUpdate) {
      drawGrid()
    }

    requestAnimationFrame(animate)
  }

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    const col = Math.floor(x / cellSize)
    const row = Math.floor(y / cellSize)

    const radius = 4
    for (let i = -radius; i <= radius; i++) {
      for (let j = -radius; j <= radius; j++) {
        const currentRow = row + i
        const currentCol = col + j

        if (currentRow >= 0 && currentRow < rows && currentCol >= 0 && currentCol < cols) {
          const distance = Math.sqrt(i * i + j * j)
          if (distance <= radius) {
            const intensity = 1 - distance / radius
            grid[currentRow][currentCol] = Math.min(grid[currentRow][currentCol] + intensity * 0.4, 1)
          }
        }
      }
    }

    drawGrid()
  })

  window.addEventListener('resize', () => {
    setupCanvas()
  })

  setupCanvas()
</script>

<style>
  canvas {
    background-color: rgb(251, 248, 241); /* neutral-100 color */
  }
</style>
