<section class="hero relative flex h-[60vh] items-center justify-center">
  <canvas id="gridCanvas" class="h-full w-full"></canvas>
  <div class="pointer-events-none absolute text-center">
    <h6 id="rotating-text" class="ml-2 inline-block text-5xl font-bold">FUN</h6>
  </div>

  <script is:inline>
    ;(() => {
      const CONFIG = {
        WAVES: [
          {
            yPos: 0.2,
            delay: 17500,
          },
          {
            yPos: 0.7,
            delay: 100,
          },
          {
            yPos: 0.9,
            delay: 45000,
          },
        ],
        ANIMATION: {
          ACTIVATION_THRESHOLD: 0.01,
          AMPLITUDE: 30,
          BASE_WAVE_SPEED: 0.02,
          BASE_WORD: 'Currently working on cirrus',
          CELL_SIZE: 8,
          DEACTIVATION_THRESHOLD: 0,
          FADE_RATE: 0.0005,
          FPS: 60,
          MOUSE_INTENSITY: 0.2,
          WAVE_INTENSITY: 0.04,
          MAX_WAVE_OFFSET: 100000,
          MOUSE_RADIUS: 4,
          NOISE_AMPLITUDE: 40,
          NOISE_OCTAVES: 2,
          NOISE_PERSISTENCE: 0.5,
          NOISE_SCALE: 0.02,
          RADIUS: 8,
          SINE_AMPLITUDE: 30,
          SINE_FREQUENCY: 0.03,
          WAVE_PATH_LENGTH: 1000,
          WAVE_SPEED_MULTIPLIER: 0.003,
          WAVE_X_SPACING: 100,
          WORD_DELAY: 100,
        },
      }

      class GridManager {
        constructor(canvas, config) {
          this.logicalWidth = 0
          this.logicalHeight = 0
          this.canvas = canvas
          this.config = config
          this.rows = 0
          this.cols = 0
          this.grid = []
          this.activeCells = new Set()
          this.dirtyCells = new Set()
          this.initGrid()
        }

        setLogicalSize(width, height) {
          this.logicalWidth = width
          this.logicalHeight = height
        }

        initGrid() {
          // Calculate based on logical dimensions
          this.rows = Math.ceil(this.logicalHeight / this.config.ANIMATION.CELL_SIZE) + 1
          this.cols =
            Math.ceil((this.logicalWidth + this.config.ANIMATION.WAVE_X_SPACING) / this.config.ANIMATION.CELL_SIZE) + 1
          this.grid = Array.from({ length: this.rows }, () => Array(this.cols).fill(0))
        }

        resizeGrid(newRows, newCols) {
          const oldGrid = this.grid
          this.grid = Array.from({ length: newRows }, (_, row) =>
            oldGrid[row]
              ? [...oldGrid[row].slice(0, newCols), ...Array(Math.max(newCols - oldGrid[row].length, 0)).fill(0)]
              : Array(newCols).fill(0),
          )
        }

        markCellDirty(row, col) {
          this.dirtyCells.add(`${row}|${col}`)
          const value = this.grid[row]?.[col] || 0
          if (value > this.config.ANIMATION.ACTIVATION_THRESHOLD) {
            this.activeCells.add(`${row}|${col}`)
          }
        }

        updateCell(row, col, value) {
          if (!this.grid[row] || Math.abs(this.grid[row][col] - value) < 0.01) return
          this.grid[row][col] = value
          this.markCellDirty(row, col)
        }

        fadeActiveCells(deltaTime) {
          const fadeAmount = deltaTime * this.config.ANIMATION.FADE_RATE * (deltaTime / 16.67)
          const fadedCells = new Set()

          this.activeCells.forEach((key) => {
            const [row, col] = key.split('|').map(Number)
            const newValue = Math.max(0, this.grid[row][col] - fadeAmount)
            this.grid[row][col] = newValue
            this.markCellDirty(row, col)

            if (newValue <= this.config.ANIMATION.DEACTIVATION_THRESHOLD) {
              fadedCells.add(key)
              this.grid[row][col] = 0
            } else {
              this.grid[row][col] = newValue
              this.markCellDirty(row, col)
            }
          })

          fadedCells.forEach((key) => this.activeCells.delete(key))
          return this.activeCells.size > 0
        }
      }

      class WaveManager {
        constructor(canvas, config) {
          this.logicalWidth = 0
          this.logicalHeight = 0
          this.canvas = canvas
          this.config = config
          this.waveStates = []
          this.noiseSeeds = []
          this.initWaves()
        }

        setLogicalSize(width, height) {
          this.logicalWidth = width
          this.logicalHeight = height
        }

        initWaves() {
          this.waveStates = this.config.WAVES.map((wave, index) => {
            this.noiseSeeds[index] = Math.random() * 1000

            return {
              amplitude: this.config.ANIMATION.SINE_AMPLITUDE,
              delay: wave.delay,
              frequency: this.config.ANIMATION.SINE_FREQUENCY,
              phase: 0,
              waveOffset: 0,
              startTime: null,
              yPos: wave.yPos,
            }
          })
        }

        getNoise(x, seed) {
          const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10)
          const lerp = (a, b, t) => a + t * (b - a)

          const X = Math.floor(x) & 255
          const x0 = x - Math.floor(x)
          const x1 = x0 - 1

          const grad = (v) => {
            const h = (Math.sin(v * 987.654 + seed) * 54321.12345) % 1
            return h * 2 - 1
          }

          const g0 = grad(X)
          const g1 = grad(X + 1)

          return lerp(g0 * x0, g1 * x1, fade(x0))
        }

        getFbmNoise(x, seed) {
          let total = 0
          let amplitude = 1
          let frequency = 1
          let maxValue = 0

          for (let i = 0; i < this.config.ANIMATION.NOISE_OCTAVES; i++) {
            total += this.getNoise(x * frequency, seed) * amplitude
            maxValue += amplitude
            amplitude *= this.config.ANIMATION.NOISE_PERSISTENCE
            frequency *= 2
          }

          return total / maxValue
        }

        calculateWavePaths() {
          this.wavePaths = this.config.WAVES.map((wave, index) => {
            const path = []
            let waveOffset = this.waveStates[index].waveOffset
            const totalTravel = this.canvas.width + this.config.ANIMATION.WAVE_X_SPACING

            for (let i = 0; i < Math.ceil(totalTravel / this.config.ANIMATION.BASE_WAVE_SPEED); i++) {
              const baseY = this.canvas.height * wave.yPos
              const y =
                baseY +
                Math.sin(waveOffset * this.config.ANIMATION.SINE_FREQUENCY) * this.config.ANIMATION.SINE_AMPLITUDE
              path.push({ x: waveOffset, y })
              waveOffset = (waveOffset + this.config.ANIMATION.BASE_WAVE_SPEED) % totalTravel
            }
            return path
          })
        }

        getCurrentWavePositions() {
          const now = performance.now()
          return this.waveStates
            .map((state, index) => {
              if (state.startTime === null) state.startTime = now + state.delay
              if (now < state.startTime) return null

              const elapsed = now - state.startTime
              const totalTravel = this.logicalWidth + this.config.ANIMATION.WAVE_X_SPACING
              state.waveOffset = (elapsed * this.config.ANIMATION.BASE_WAVE_SPEED) % totalTravel

              const baseY = this.logicalHeight * state.yPos

              // Core sine wave
              const sineY = Math.sin(state.waveOffset * state.frequency) * state.amplitude

              // Noise-based wobble
              const noiseX = state.waveOffset * this.config.ANIMATION.NOISE_SCALE
              const noiseY = this.getFbmNoise(noiseX, this.noiseSeeds[index]) * this.config.ANIMATION.NOISE_AMPLITUDE

              const y = baseY + sineY + noiseY

              return {
                x: state.waveOffset,
                y: Math.min(Math.max(y, 0), this.logicalHeight),
              }
            })
            .filter(Boolean)
        }
      }

      class GridAnimation {
        constructor() {
          this.config = CONFIG
          this.canvas = document.getElementById('gridCanvas')
          this.ctx = this.canvas?.getContext('2d')
          this.rotatingText = document.getElementById('rotating-text')
          this.gridManager = new GridManager(this.canvas, this.config)
          this.waveManager = new WaveManager(this.canvas, this.config)
          this.animationState = {
            isVisible: true,
            lastUpdate: performance.now(),
            frameId: null,
            mouseQueue: [],
          }
          this.setupEventListeners()
          this.init()
        }

        init() {
          if (!this.canvas || !this.ctx) return
          this.setupCanvas()
          this.startAnimation()
          this.startTextRotation()
        }

        setupCanvas() {
          // Ensure canvas dimensions match displayed size
          const dpr = window.devicePixelRatio || 1
          const rect = this.canvas.getBoundingClientRect()

          this.logicalWidth = rect.width
          this.logicalHeight = rect.height

          this.canvas.width = rect.width * dpr
          this.canvas.height = rect.height * dpr
          this.ctx.scale(dpr, dpr)

          this.gridManager.setLogicalSize(this.logicalWidth, this.logicalHeight)
          this.waveManager.setLogicalSize(this.logicalWidth, this.logicalHeight)

          this.gridManager.initGrid()
          this.waveManager.initWaves()
          this.draw()
        }

        startAnimation() {
          let lastTime = performance.now()

          const animate = (currentTime) => {
            const deltaTime = currentTime - lastTime
            lastTime = currentTime

            if (this.animationState.isVisible) {
              this.update(currentTime, deltaTime)
              this.draw()
            }

            this.animationState.frameId = requestAnimationFrame(animate)
          }

          animate(lastTime)
        }

        update(now) {
          const deltaTime = now - this.animationState.lastUpdate

          this.processMouseInput()
          this.updateWaves()

          // Always redraw even if fading to ensure smooth updates
          const hasActive = this.gridManager.fadeActiveCells(deltaTime)
          this.draw()
          this.animationState.lastUpdate = now
        }

        processMouseInput() {
          this.animationState.mouseQueue.forEach(([x, y]) => {
            this.applyRadiusEffect(x, y, this.config.ANIMATION.MOUSE_RADIUS, true)
          })
          this.animationState.mouseQueue = []
        }

        updateWaves() {
          this.waveManager.getCurrentWavePositions().forEach(({ x, y }) => {
            this.applyRadiusEffect(x, y, this.config.ANIMATION.RADIUS)
          })
        }

        applyRadiusEffect(x, y, radius, isMouse = false) {
          const cellSize = this.config.ANIMATION.CELL_SIZE
          const col = Math.floor(x / cellSize)
          const row = Math.floor(y / cellSize)

          for (let i = -radius; i <= radius; i++) {
            for (let j = -radius; j <= radius; j++) {
              const currentRow = row + i
              const currentCol = col + j
              if (this.isValidCell(currentRow, currentCol)) {
                const distance = Math.hypot(i, j)
                if (distance <= radius) {
                  const intensity =
                    (1 - distance / radius) *
                    (isMouse ? this.config.ANIMATION.MOUSE_INTENSITY : this.config.ANIMATION.WAVE_INTENSITY)
                  // Ensure cells stay active longer by capping intensity
                  this.gridManager.updateCell(
                    currentRow,
                    currentCol,
                    Math.min(this.gridManager.grid[currentRow][currentCol] + intensity, 1),
                  )
                }
              }
            }
          }
        }

        isValidCell(row, col) {
          return row >= 0 && row < this.gridManager.rows && col >= 0 && col < this.gridManager.cols
        }

        draw() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)

          const cellSize = this.config.ANIMATION.CELL_SIZE
          const opacityGroups = new Map()

          // Draw all active cells, not just dirty ones
          this.gridManager.activeCells.forEach((key) => {
            const [row, col] = key.split('|').map(Number)
            const opacity = this.gridManager.grid[row][col]
            const quantized = Math.floor(opacity * 40) / 40

            if (!opacityGroups.has(quantized)) {
              opacityGroups.set(quantized, new Path2D())
            }

            const x = col * cellSize
            const y = row * cellSize
            opacityGroups.get(quantized).rect(x, y, cellSize - 1, cellSize - 1)
          })
          const sortedOpacities = Array.from(opacityGroups.keys()).sort((a, b) => a - b)

          sortedOpacities.forEach((opacity, index) => {
            this.ctx.fillStyle = `rgba(40, 54, 24, ${opacity * 0.95})`
            this.ctx.fill(opacityGroups.get(opacity))
          })

          this.gridManager.dirtyCells.clear()
        }

        startTextRotation() {
          const words = Array.from({ length: this.config.ANIMATION.BASE_WORD.length }, (_, i) => {
            const chars = [...this.config.ANIMATION.BASE_WORD.toLowerCase()]
            chars[i] = chars[i].toUpperCase()
            return chars.join('')
          })

          let currentIndex = 0
          const rotate = () => {
            this.rotatingText.textContent = words[currentIndex]
            currentIndex = (currentIndex + 1) % words.length
            setTimeout(rotate, this.config.ANIMATION.WORD_DELAY)
          }
          rotate()
        }

        setupEventListeners() {
          const resizeObserver = new ResizeObserver(() => this.setupCanvas())
          resizeObserver.observe(this.canvas)

          const handleResize = () => {
            cancelAnimationFrame(this.animationState.frameId)
            setTimeout(() => {
              this.setupCanvas()
              this.startAnimation()
            }, 200)
          }

          const handleVisibility = () => {
            this.animationState.isVisible = !document.hidden
            if (this.animationState.isVisible) this.startAnimation()
          }

          window.addEventListener('resize', handleResize)
          document.addEventListener('visibilitychange', handleVisibility)
          this.canvas.addEventListener(
            'mousemove',
            (e) => {
              const rect = this.canvas.getBoundingClientRect()
              this.animationState.mouseQueue.push([e.clientX - rect.left, e.clientY - rect.top])
            },
            { passive: true },
          )

          // Cleanup handlers
          this.dispose = () => {
            window.removeEventListener('resize', handleResize)
            resizeObserver.unobserve(this.canvas)
            document.removeEventListener('visibilitychange', handleVisibility)
            cancelAnimationFrame(this.animationState.frameId)
          }
        }
      }

      // Astro Integration
      let animationInstance = null

      const initAnimation = () => {
        if (!animationInstance) animationInstance = new GridAnimation()
      }

      const cleanupAnimation = () => {
        if (animationInstance) {
          animationInstance.dispose()
          animationInstance = null
        }
      }

      if (typeof window !== 'undefined') {
        document.addEventListener('astro:beforeunload', cleanupAnimation)
        document.addEventListener('astro:after-swap', () => {
          cleanupAnimation()
          initAnimation()
        })

        if (document.readyState === 'complete') initAnimation()
        else window.addEventListener('load', initAnimation)
      }
    })()
  </script>
</section>

<style>
  canvas {
    background-color: var(--background);
  }
  .hero::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 25%;
    background: linear-gradient(to bottom, transparent 0%, var(--background) 100%);
    pointer-events: none;
    z-index: 1;
  }
</style>
